public class DubboTest {
    /**
     * Dubbo（阿里早期RPC框架）
     * Provider
     * 暴露服务方称之为“服务提供者”。
     * Consumer
     * 调用远程服务方称之为“服务消费者”。
     * Registry
     * 服务注册与发现的中心目录服务称之为“服务注册中心”。
     * Monitor
     * 统计服务的调用次数和调用时间的日志服务称之为“服务监控中心”。
     *
     * 1:连通性 注册中心 服务提供者，服务消费者三者保持长连接 注册中心根据长连接感知提供者是否存活，一旦发现服务提供者宕机 则注册中心立刻提供给消费者
     *     注册中心和监控中心宕机 不影响已运行的提供者和消费者，因为消费者已经把服务提供者信息缓存在了本地，
     *   服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销
     *
     *   服务提供方：服务暴露到zookeeper
     *   服务启动过程，Protocal通过Proxy将需要暴露的接口封装成一个invoker 是一个可执行体，exporter包装invoker 并发送到注册中心完成注册
     *
     *   服务消费：
     *   1：服务消费启动时会先向注册中心订阅并拉取所需服务提供者的信息，保存到本地缓存（因此注册中心和监控中心宕机 不影响已运行的提供者和消费者，
     *   因为消费者已经把服务提供者信息缓存在了本地，）
     *   2：消费方调用的地方 会使用Protocal生成一个代理类 代理类持有一个invoker对象，
     *   先通过Cluster从Directory中获取所有可调用的此远程invoker列表，如果配置了某些断言路由还会过滤 之后走一个LoadBalance负载均衡调用某一个invoker
     *   通过filter进行一些数据统计，之后将这些数据保存下来，定时发送给mintor
     *   3：接下来到使用client做数据传输（netty mina等）通过CodeC协议构造和Seriakization序列化 将这些二进制流发送给服务提供者，
     *   4：服务提供者接收到二进制流后也会进行Codec协议处理，然后进行反序列化（此处的处理与传输之前的处理是呈对称的）
     *   后将请求放入线程池中处理，某个线程会根据请求找到对应的Exporter，然后再通过Filter进行层层过滤得到Invoker，最终调用对应的实现类然后将结果原路返回
     */

    /**
     * 1
     */
}
